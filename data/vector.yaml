data_dir: /var/lib/vector

sources:
  system_logs:
    type: "journald"
    journal_directory: "/var/log/journal"
    include_units: ["ssh.service", "sshd.service"]
    # Removed current_boot_only so the entire journal history is read

transforms:
  ssh_events:
    type: "remap"
    inputs: ["system_logs"]
    source: |
      identifier = to_string(.SYSLOG_IDENTIFIER) ?? ""
      message = to_string(.message) ?? ""
      if !contains(identifier, "sshd") {
        . = null
      } else {
        # Use the native timestamp if available; fall back to now()
        .ts = if exists(.timestamp) {
          format_timestamp!(.timestamp, format: "%Y-%m-%dT%H:%M:%S%.3fZ")
        } else {
          now()
        }
        .hostname = to_string(.host) ?? "unknown"
        .content = message
        
        if contains(message, "Accepted password") {
          events = parse_regex(message, r'Accepted password for (?P<username>[^\s]+) from (?P<ip_address>[^\s]+)') ?? null
          if events != null {
            .event_type = "login"
            .status = "success"
            .username = events.username
            .ip_address = events.ip_address
            .auth_method = "password"
          } else {
            . = null
          }
        } else if contains(message, "Failed password") {
          events = parse_regex(message, r'Failed password for (?:invalid user )?(?P<username>[^\s]+) from (?P<ip_address>[^\s]+)') ?? null
          if events != null {
            .event_type = "login"
            .status = "failed"
            .username = events.username
            .ip_address = events.ip_address
            .auth_method = "password"
          } else {
            . = null
          }
        } else if contains(message, "session opened for user") {
          # Drop all session_open events from journald
          . = null
        } else {
          . = null
        }
      }


sinks:
  sqlite_sink:
    type: "http"
    inputs: ["ssh_events"]
    uri: "http://app:3000/api/log-events"
    encoding:
      codec: "json"
    method: "post"
    request:
      headers:
        "Content-Type": "application/json"
      retry_max_retries: 5
      retry_initial_backoff_secs: 1
      timeout_secs: 60
    healthcheck:
      enabled: true
